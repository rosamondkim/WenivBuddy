# 질문

## 질문예시

![이미지](/uploads/1765280824066-0bc364481a0ecdbb.png) 저 클로드 설치 명령어 넣었는데 이렇게 뜹니다

## 답변예시

저 내용은 Window 보안설정 문제에요!

1번부터 순서대로 해보실래요?

1. PowerShell을 관리자 권한으로 열기
   `시작 버튼 → PowerShell 검색 → Windows PowerShell 우클릭 → 관리자 권한으로 실행`

2. 아래 명령어를 입력하세요!
   `Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass`

3. 해당 명령어를 쳐서 아무것도 출력이 안될 수도 있고, 아래와 같은 선택지가 나올 수도 있는데요.
   `[Y] 예(Y)  [A] 모두 예(A)  [N] 아니요(N)  [L] 모두 아니요(L)  [S] 일시 중단(S)  [?] 도움말 (기본값은 "N"임):`
   여기서 A를 눌러주시면 됩니다!

이제 그 창에서 그대로 아래 설치를 재시도 해보세요. 해보시고 말씀 해주실래요?

위 내용으로 추출하면
"keywords": [
"설치",
"이미지",
"png",
"클로드",
"명령어",
"이렇게",
"넣었는데",
"클로드 설치",
"uploads",
"이미지 uploads",
"0bc364481a0ecdbb png",
"uploads 1765280824066",
"1765280824066 0bc364481a0ecdbb"]

이렇게 불필요한 키워드들이 너무 많이 추출돼.
이미지,png,uploads 등은 불필요한 키워드들이야. 이걸 어떻게 개선하면 될까?

# 답변

## 문제 분석

질문에 이미지 마크다운이 포함되어 있습니다:

```
![이미지](/uploads/1765280824066-0bc364481a0ecdbb.png)
```

이것이 텍스트로 처리되면서 다음과 같은 불필요한 키워드가 추출됩니다:

- "이미지", "png" - 파일 형식
- "uploads" - 경로
- "0bc364481a0ecdbb", "1765280824066" - 파일명 해시와 타임스탬프

## 추천 개선 방법 ⭐

### 방법 1: 키워드 추출 전에 이미지 마크다운 제거 (가장 효과적)

키워드 추출 함수에서 텍스트를 정규화할 때 이미지 마크다운을 제거합니다.

**구현 위치**: `lib/keyword-extractor.js`의 `extractKeywords` 함수

```javascript
export function extractKeywords(question, options = {}) {
  if (!question || typeof question !== "string") {
    return [];
  }

  // 이미지 마크다운 제거 (예: ![alt](/path/to/image.png))
  const cleanedQuestion = question.replace(/!\[([^\]]*)\]\([^)]+\)/g, "");

  const { maxKeywords = 20, isOCR = false } = options;
  // ... 나머지 코드에서 cleanedQuestion 사용
}
```

**효과**:

```
입력: "![이미지](/uploads/1765280824066-0bc364481a0ecdbb.png) 저 클로드 설치 명령어 넣었는데 이렇게 뜹니다"
↓ 정제 후
"저 클로드 설치 명령어 넣었는데 이렇게 뜹니다"
↓ 추출 결과
["클로드", "설치", "명령어", "PowerShell", ...]
```

### 방법 2: 불용어 목록 확장

이미지 관련 단어를 불용어에 추가합니다.

```javascript
const STOP_WORDS = new Set([
  // 기존 불용어...
  "이미지",
  "그림",
  "사진",
  "스크린샷",
  "캡처",
  "png",
  "jpg",
  "jpeg",
  "gif",
  "svg",
  "webp",
  "uploads",
  "images",
]);
```

**단점**: 정말로 "이미지"가 키워드인 경우(예: "SVG 이미지 문제")도 제외됨

### 방법 3: 파일 경로 및 해시 패턴 제외

숫자로만 된 단어나 해시처럼 보이는 단어를 필터링합니다.

```javascript
function extractNouns(text) {
  const words = text.split(/\s+/);
  const nouns = [];

  for (const word of words) {
    // 숫자만 있는 단어 제외
    if (/^\d+$/.test(word)) {
      continue;
    }

    // 해시처럼 보이는 긴 영숫자 조합 제외 (10자 이상)
    if (/^[a-f0-9]{10,}$/i.test(word)) {
      continue;
    }

    // 한글만 있는 단어
    if (/^[가-힣]+$/.test(word)) {
      // ... 기존 로직
    }
  }

  return nouns;
}
```

### 방법 4: LLM 사용 강제 (이미 구현됨)

현재 OCR 모드에서는 LLM이 자동으로 불필요한 키워드를 필터링합니다.
하지만 이 경우는 OCR이 아니라 일반 텍스트이므로, 이미지 마크다운이 포함된 경우에도 LLM을 사용하도록 감지 로직을 추가할 수 있습니다.

```javascript
// lib/hybrid-keyword-extractor.js에서
let isOCR = isOCRInput;

// 이미지 마크다운이 포함된 경우 LLM 사용
if (!isOCR && /!\[([^\]]*)\]\([^)]+\)/g.test(question)) {
  console.log(
    "🖼️ [Hybrid] Image markdown detected - using LLM for better filtering"
  );
  isOCR = true; // LLM 강제 사용
}
```

## 추천 구현 순서

1. **방법 1 (필수)**: 이미지 마크다운 제거 - 가장 확실한 해결책
2. **방법 3 (선택)**: 해시 패턴 제외 - 추가 안전장치
3. **방법 2 (선택)**: 불용어 확장 - 필요시 추가

방법 1만 구현해도 대부분의 문제가 해결됩니다.

## 추가 고려사항

### 다른 마크다운 구문도 제거

```javascript
function cleanMarkdown(text) {
  return text
    .replace(/!\[([^\]]*)\]\([^)]+\)/g, "") // 이미지
    .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1") // 링크 (텍스트만 남김)
    .replace(/`{1,3}[^`]+`{1,3}/g, "") // 코드 블록
    .replace(/#{1,6}\s+/g, "") // 헤딩
    .trim();
}
```

### API 레벨에서도 처리

`/api/extract-keywords-hybrid`에서 호출 전에 정제:

```javascript
const cleanedQuestion = cleanMarkdown(question);
const extractionResult = await extractKeywordsHybrid(cleanedQuestion, {
  isOCR,
});
```
