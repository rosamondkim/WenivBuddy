{
  "qnaList": [
    {
      "id": "qna-001",
      "category": "도구",
      "question": "VSC에서 SVG 이미지를 클릭했을 때, 강사님처럼 코드가 나오는게 아니라 전 이미지가 나와요!",
      "keywords": ["VSC", "VSCode", "SVG", "이미지", "코드", "뷰어", "에디터"],
      "answer": "VS Code에서 SVG 파일을 클릭했을 때 이미지로 보이는 것은 기본 설정 때문입니다.\n\nSVG 파일을 코드로 보려면:\n1. SVG 파일에서 마우스 우클릭\n2. '연결 프로그램...' 또는 'Open With...' 선택\n3. 'Text Editor' 또는 '텍스트 편집기' 선택\n\n또는 확장 프로그램을 사용할 수 있습니다:\n- 'SVG' 확장 프로그램 설치\n- 설정에서 기본 에디터를 텍스트 편집기로 변경\n\n단축키로는 SVG 파일을 선택하고 Ctrl+K, Ctrl+O (Mac: Cmd+K, Cmd+O)를 누르면 편집기 선택 옵션이 나타납니다.",
      "author": "김코딩 강사",
      "timestamp": "2024-12-01T10:30:00",
      "imageUrl": "/images/vscode-svg-settings.png",
      "views": 42
    },
    {
      "id": "qna-002",
      "category": "Frontend",
      "question": "React에서 useState 초기값을 설정할 때 함수를 넣는 이유가 뭔가요?",
      "keywords": ["React", "useState", "초기값", "함수", "지연 초기화", "lazy initialization", "성능"],
      "answer": "useState의 초기값으로 함수를 전달하는 것은 '지연 초기화(Lazy Initialization)' 기법입니다.\n\n일반적인 방법:\nconst [state, setState] = useState(expensiveFunction());\n// expensiveFunction()이 매 렌더링마다 실행됩니다.\n\n함수를 사용한 방법:\nconst [state, setState] = useState(() => expensiveFunction());\n// expensiveFunction()이 첫 렌더링에만 실행됩니다.\n\n장점:\n1. 초기값 계산이 복잡하거나 비용이 큰 경우 성능 향상\n2. localStorage 접근, 복잡한 연산 등에 유용\n3. 불필요한 재계산 방지\n\n예시:\nconst [user, setUser] = useState(() => {\n  const saved = localStorage.getItem('user');\n  return saved ? JSON.parse(saved) : { name: '', email: '' };\n});",
      "author": "박리액트 강사",
      "timestamp": "2024-12-02T14:15:00",
      "imageUrl": "/images/react-usestate-lazy.png",
      "views": 87
    },
    {
      "id": "qna-003",
      "category": "CSS",
      "question": "flexbox에서 justify-content와 align-items 차이가 헷갈려요",
      "keywords": ["CSS", "flexbox", "justify-content", "align-items", "정렬", "레이아웃", "주축", "교차축"],
      "answer": "Flexbox의 정렬 속성은 주축(main axis)과 교차축(cross axis) 개념으로 이해하면 쉽습니다.\n\njustify-content:\n- 주축(main axis) 방향 정렬\n- flex-direction: row → 가로 방향 정렬\n- flex-direction: column → 세로 방향 정렬\n\nalign-items:\n- 교차축(cross axis) 방향 정렬\n- flex-direction: row → 세로 방향 정렬\n- flex-direction: column → 가로 방향 정렬\n\n예시:\n.container {\n  display: flex;\n  flex-direction: row; /* 기본값 */\n  justify-content: center; /* 가로 가운데 */\n  align-items: center; /* 세로 가운데 */\n}\n\n쉽게 기억하는 방법:\n- justify = 메인 방향 (컨텐츠가 흐르는 방향)\n- align = 반대 방향 (아이템들이 정렬되는 방향)",
      "author": "이스타일 강사",
      "timestamp": "2024-12-02T16:45:00",
      "imageUrl": "/images/flexbox-alignment.png",
      "views": 156
    },
    {
      "id": "qna-004",
      "category": "JavaScript",
      "question": "async/await을 사용할 때 try-catch 없이 에러를 처리할 수 있나요?",
      "keywords": ["JavaScript", "async", "await", "에러", "에러처리", "try-catch", "Promise", "catch"],
      "answer": "async/await에서 try-catch 없이 에러를 처리하는 방법이 있습니다.\n\n방법 1: .catch() 메서드 사용\nasync function fetchData() {\n  const data = await fetch('/api/data')\n    .then(res => res.json())\n    .catch(err => {\n      console.error('에러 발생:', err);\n      return null; // 기본값 반환\n    });\n  return data;\n}\n\n방법 2: 에러 핸들러 래퍼 함수\nconst asyncHandler = (fn) => {\n  return async (...args) => {\n    try {\n      return [null, await fn(...args)];\n    } catch (error) {\n      return [error, null];\n    }\n  };\n};\n\n// 사용\nconst [error, data] = await asyncHandler(fetchData)();\nif (error) console.error(error);\n\n방법 3: Promise의 .then().catch() 체이닝\nawait fetch('/api/data')\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n\n하지만 가독성과 명확성을 위해 try-catch를 사용하는 것이 권장됩니다.",
      "author": "최자바 강사",
      "timestamp": "2024-12-03T09:20:00",
      "imageUrl": "/images/async-error-handling.png",
      "views": 93
    },
    {
      "id": "qna-005",
      "category": "Git",
      "question": "git stash를 사용하는 상황이 정확히 언제인가요?",
      "keywords": ["Git", "stash", "임시저장", "브랜치", "변경사항", "작업중", "전환"],
      "answer": "git stash는 현재 작업 중인 변경사항을 임시로 저장할 때 사용합니다.\n\n주요 사용 상황:\n\n1. 브랜치 전환이 필요할 때\n- 현재 작업이 완료되지 않았지만 다른 브랜치로 전환해야 할 때\n- git stash로 작업 저장 → 브랜치 전환 → 작업 후 → git stash pop으로 복원\n\n2. 긴급 수정이 필요할 때\n- 새 기능 개발 중 버그 수정 요청이 들어올 때\n- 현재 작업을 stash → 버그 수정 → 다시 원래 작업 복원\n\n3. 실험적 코드를 시도할 때\n- 현재 작업을 stash → 실험 → 실패 시 git reset → stash pop\n\n기본 명령어:\ngit stash              # 현재 변경사항 저장\ngit stash list         # stash 목록 확인\ngit stash pop          # 가장 최근 stash 적용 및 삭제\ngit stash apply        # stash 적용 (삭제하지 않음)\ngit stash drop         # stash 삭제\ngit stash clear        # 모든 stash 삭제\n\n메시지와 함께 저장:\ngit stash save \"작업 설명\"",
      "author": "정깃헙 강사",
      "timestamp": "2024-12-03T11:00:00",
      "imageUrl": "/images/git-stash-workflow.png",
      "views": 67
    },
    {
      "id": "qna-006",
      "category": "Backend",
      "question": "Express에서 미들웨어 순서가 중요한 이유가 뭔가요?",
      "keywords": ["Express", "Node.js", "미들웨어", "middleware", "순서", "실행순서", "req", "res"],
      "answer": "Express에서 미들웨어는 요청이 들어온 순서대로 실행되기 때문에 순서가 매우 중요합니다.\n\n잘못된 예시 (에러 발생):\napp.use(express.json());      // 1. JSON 파싱\napp.post('/api/data', handler); // 2. 라우트 핸들러\napp.use(cors());              // 3. CORS (너무 늦음!)\n\n올바른 예시:\napp.use(cors());              // 1. CORS 먼저\napp.use(express.json());      // 2. body 파싱\napp.use(express.urlencoded()); // 3. URL 인코딩\napp.use(morgan('dev'));       // 4. 로깅\napp.use('/api', apiRouter);   // 5. 라우트\napp.use(errorHandler);        // 6. 에러 핸들러 (가장 마지막)\n\n주요 원칙:\n1. CORS는 가장 먼저\n2. body parser는 라우트 전에\n3. 인증/인가는 보호가 필요한 라우트 전에\n4. 에러 핸들러는 가장 마지막에\n5. 404 핸들러는 모든 라우트 이후에\n\n예시:\napp.use(cors());\napp.use(express.json());\napp.use('/public', express.static('public'));\napp.use(authMiddleware); // 인증이 필요한 라우트 전에\napp.use('/api', apiRouter);\napp.use(notFoundHandler);\napp.use(errorHandler);",
      "author": "강노드 강사",
      "timestamp": "2024-12-03T13:30:00",
      "imageUrl": "/images/express-middleware-order.png",
      "views": 121
    },
    {
      "id": "qna-007",
      "category": "도구",
      "question": "VSCode에서 Emmet 단축키가 작동하지 않아요",
      "keywords": ["VSCode", "Emmet", "단축키", "자동완성", "HTML", "CSS", "설정"],
      "answer": "VSCode에서 Emmet이 작동하지 않는 경우 다음을 확인해보세요.\n\n1. 파일 언어 모드 확인\n- 우측 하단의 언어 모드가 올바른지 확인 (HTML, JSX 등)\n- 잘못된 경우: 언어 모드 클릭 → 올바른 언어 선택\n\n2. settings.json 설정 추가\n{\n  \"emmet.includeLanguages\": {\n    \"javascript\": \"javascriptreact\",\n    \"typescript\": \"typescriptreact\"\n  },\n  \"emmet.triggerExpansionOnTab\": true,\n  \"emmet.showExpandedAbbreviation\": \"always\"\n}\n\n3. JSX/TSX에서 Emmet 사용\n- React 파일(.jsx, .tsx)에서는 추가 설정 필요\n- 위의 includeLanguages 설정 확인\n\n4. Tab 키 설정\n- Tab 키로 Emmet 확장: triggerExpansionOnTab: true\n\n5. 확장 프로그램 충돌\n- 다른 자동완성 확장 프로그램이 Emmet을 방해할 수 있음\n- 확장 프로그램을 하나씩 비활성화하여 테스트\n\n자주 사용하는 Emmet 약어:\n- div.container>ul>li*3\n- header+main+footer\n- ul>li.item$*5",
      "author": "김코딩 강사",
      "timestamp": "2024-12-03T15:00:00",
      "imageUrl": "/images/vscode-emmet-settings.png",
      "views": 78
    },
    {
      "id": "qna-008",
      "category": "CSS",
      "question": "position: absolute를 사용하면 요소가 사라져요",
      "keywords": ["CSS", "position", "absolute", "relative", "레이아웃", "부모요소", "배치"],
      "answer": "position: absolute를 사용할 때 요소가 '사라지는' 것처럼 보이는 이유와 해결 방법입니다.\n\n문제 원인:\n- absolute는 부모 요소를 기준으로 배치됨\n- 부모에 position 속성이 없으면 body를 기준으로 배치\n- 좌표(top, left 등)를 지정하지 않으면 원래 위치에 있지만 문서 흐름에서 제외됨\n\n해결 방법:\n\n1. 부모 요소에 position 지정\n.parent {\n  position: relative; /* 기준점 설정 */\n}\n\n.child {\n  position: absolute;\n  top: 10px;\n  left: 10px;\n}\n\n2. 좌표 명시적으로 지정\n.element {\n  position: absolute;\n  top: 0;    /* 또는 원하는 값 */\n  left: 0;   /* 또는 원하는 값 */\n}\n\n3. z-index로 쌓임 순서 조정\n.element {\n  position: absolute;\n  z-index: 10; /* 다른 요소 위에 표시 */\n}\n\nposition 속성 비교:\n- static: 기본값, 문서 흐름대로\n- relative: 원래 위치 기준, 문서 흐름 유지\n- absolute: 부모 기준, 문서 흐름에서 제외\n- fixed: 뷰포트 기준, 스크롤해도 고정\n- sticky: 스크롤 위치에 따라 변함",
      "author": "이스타일 강사",
      "timestamp": "2024-12-04T09:15:00",
      "imageUrl": "/images/css-position-absolute.png",
      "views": 134
    }
  ]
}
